이 가이드는 ProseMirror에서 사용되는 핵심 개념들과 이들의 관계를 설명합니다. 시스템을 제대로 이해하려면 적어도 "뷰 컴포넌트" 부분까지는 순서대로 읽어보시길 권장합니다.

## ProseMirror란?

ProseMirror는 워드프로세서처럼 글을 쓸 수 있는 에디터를 만들기 위한 도구 모음입니다. 워드나 한글 같은 프로그램처럼 보이는 사용자 화면을 제공하지만, 그런 프로그램들의 문제점은 피하려고 노력합니다.

ProseMirror의 핵심 철학은 개발자가 문서와 문서에서 일어나는 모든 일을 완벽하게 통제할 수 있다는 것입니다. 문서는 단순한 HTML 덩어리가 아니라, 개발자가 명확하게 허용한 요소만 포함할 수 있는 맞춤형 구조입니다. 모든 변경사항은 하나의 통로를 거치기 때문에, 개발자는 이를 확인하고 원하는 방식으로 처리할 수 있습니다.

핵심 라이브러리는 바로 사용할 수 있는 완제품이 아닙니다. 저희는 단순함보다 유연성과 맞춤 설정을 우선시하며, 앞으로 다른 개발자들이 ProseMirror를 활용한 즉시 사용 가능한 에디터를 만들기를 기대합니다. 완성된 장난감 자동차라기보다는 조립할 수 있는 레고 세트에 가깝다고 보시면 됩니다.

편집 기능을 위해 필요한 네 가지 핵심 모듈이 있으며, 추가로 여러 확장 모듈들이 있습니다. 확장 모듈들은 유용한 기능을 제공하지만 필수는 아니며, 다른 모듈로 대체할 수도 있습니다.

필수 모듈들:

- **prosemirror-model**: 에디터의 문서 구조를 정의합니다. 에디터 콘텐츠를 설명하는 데이터 구조입니다.
- **prosemirror-state**: 선택 영역을 포함한 에디터의 전체 상태를 설명하는 구조와, 상태 변경을 위한 트랜잭션 시스템을 제공합니다.
- **prosemirror-view**: 에디터 상태를 브라우저에서 편집 가능한 화면으로 보여주고, 사용자의 입력을 처리합니다.
- **prosemirror-transform**: 문서를 기록하고 재생 가능한 방식으로 수정하는 기능을 포함합니다. 실행 취소 기능과 공동 편집을 가능하게 합니다.

추가로 기본 편집 명령, 키보드 단축키, 실행 취소 기록, 입력 자동완성, 공동 편집, 기본 문서 스키마 등을 위한 모듈들도 있습니다.

ProseMirror가 하나의 파일로 제공되지 않기 때문에, 사용하려면 번들러라는 도구를 사용해야 합니다. 번들러는 여러 파일의 의존성을 자동으로 찾아서 웹 페이지에서 쉽게 불러올 수 있는 하나의 큰 파일로 합쳐주는 도구입니다.

## 첫 번째 에디터 만들기

레고 조각들을 다음과 같이 조립하면 아주 기본적인 에디터를 만들 수 있습니다:

```javascript
import { schema } from "prosemirror-schema-basic";
import { EditorState } from "prosemirror-state";
import { EditorView } from "prosemirror-view";

let state = EditorState.create({ schema });
let view = new EditorView(document.body, { state });
```

ProseMirror는 문서가 따라야 할 스키마(규칙)를 지정하도록 요구하므로, 먼저 기본 스키마를 가져옵니다.

그런 다음 해당 스키마로 상태를 만듭니다. 이 상태는 스키마 규칙을 따르는 빈 문서와 문서 시작 부분의 기본 커서 위치를 생성합니다. 마지막으로 상태를 표시할 뷰를 만들고 웹 페이지에 추가합니다. 이렇게 하면 문서가 편집 가능한 화면으로 보이고, 사용자가 입력할 때마다 상태 변경을 처리합니다.

하지만 이 에디터는 아직 충분히 유용하지 않습니다. 예를 들어 엔터 키를 눌러도 아무 일도 일어나지 않는데, 핵심 라이브러리가 엔터 키가 어떻게 동작해야 하는지에 대한 기본 설정이 없기 때문입니다. 이 부분은 곧 다루겠습니다.

## 트랜잭션 이해하기

사용자가 타이핑하거나 에디터와 상호작용할 때, 뷰는 '상태 트랜잭션'을 생성합니다. 이는 문서를 직접 수정하지 않고 상태를 암묵적으로 업데이트하지 않는다는 의미입니다. 대신, 모든 변경은 트랜잭션을 생성하며, 이는 상태에 대한 변경사항을 설명하고 새로운 상태를 만드는 데 적용됩니다. 그 다음 이 새로운 상태가 뷰를 업데이트하는 데 사용됩니다.

기본적으로 이 모든 과정은 자동으로 일어나지만, 플러그인을 작성하거나 뷰를 설정하여 이 과정에 개입할 수 있습니다. 예를 들어, 다음 코드는 트랜잭션이 생성될 때마다 호출되는 함수를 추가합니다:

```javascript
let state = EditorState.create({ schema });
let view = new EditorView(document.body, {
  state,
  dispatchTransaction(transaction) {
    console.log(
      "문서 크기가",
      transaction.before.content.size,
      "에서",
      transaction.doc.content.size,
      "로 변경되었습니다"
    );
    let newState = view.state.apply(transaction);
    view.updateState(newState);
  },
});
```

모든 상태 업데이트는 `updateState`를 통과해야 하며, 모든 일반적인 편집 업데이트는 트랜잭션을 전달함으로써 발생합니다.

## 플러그인으로 기능 확장하기

플러그인은 에디터와 에디터 상태의 동작을 다양한 방식으로 확장하는 데 사용됩니다. 일부 플러그인은 키맵 플러그인처럼 비교적 간단하여 키보드 입력에 특정 동작을 연결합니다. 다른 플러그인들은 더 복잡합니다. 예를 들어 히스토리 플러그인은 트랜잭션을 관찰하고 사용자가 실행 취소하고자 할 경우를 대비해 역방향 트랜잭션을 저장함으로써 실행 취소 기능을 구현합니다.

에디터에 실행 취소/재실행 기능을 추가하기 위해 다음 두 플러그인을 추가해봅시다:

```javascript
import { undo, redo, history } from "prosemirror-history";
import { keymap } from "prosemirror-keymap";

let state = EditorState.create({
  schema,
  plugins: [history(), keymap({ "Mod-z": undo, "Mod-y": redo })],
});
let view = new EditorView(document.body, { state });
```

플러그인은 상태를 만들 때 등록됩니다(플러그인이 상태 트랜잭션에 접근하기 때문입니다). 히스토리가 활성화된 상태로 뷰를 만든 후에는, Ctrl-Z(또는 맥에서는 Cmd-Z)를 눌러서 마지막 변경사항을 실행 취소할 수 있습니다.

## 명령 사용하기

이전 예제에서 키에 연결된 `undo`와 `redo` 값은 '명령'이라고 불리는 특별한 종류의 함수입니다.

대부분의 편집 동작은 키에 연결되거나, 메뉴에 표시되거나, 다른 방식으로 사용자에게 제공될 수 있는 명령으로 작성됩니다.

`prosemirror-commands` 패키지는 여러 기본 편집 명령과 함께, 엔터나 삭제 같은 키들이 에디터에서 예상대로 작동하도록 하기 위해 활성화하고 싶을 최소한의 키 설정을 제공합니다.

```javascript
import { baseKeymap } from "prosemirror-commands";

let state = EditorState.create({
  schema,
  plugins: [
    history(),
    keymap({ "Mod-z": undo, "Mod-y": redo }),
    keymap(baseKeymap),
  ],
});
let view = new EditorView(document.body, { state });
```

이 시점에서 기본적으로 작동하는 에디터를 갖게 됩니다.

메뉴, 스키마 관련 추가 키보드 단축키 등을 추가하려면 `prosemirror-example-setup` 패키지를 살펴보는 것이 좋습니다. 이것은 기본 에디터를 설정하는 플러그인 모음을 제공하는 모듈이지만, 이름처럼 실제 서비스용이라기보다는 예제로 의도되었습니다. 실제 서비스를 위해서는 원하는 대로 정확하게 설정하는 맞춤 코드로 대체하고 싶을 것입니다.

## 콘텐츠 다루기

상태의 문서는 `doc` 속성 아래에 있습니다. 이것은 읽기 전용 데이터 구조로, 문서를 브라우저 DOM과 다소 유사한 노드의 계층 구조로 나타냅니다. 간단한 문서는 각각 하나의 "텍스트" 노드를 포함하는 두 개의 "단락" 노드를 포함하는 "문서" 노드일 수 있습니다.

상태를 초기화할 때 사용할 초기 문서를 제공할 수 있습니다. 이 경우 `schema` 필드는 선택사항인데, 스키마를 문서에서 가져올 수 있기 때문입니다.

여기서는 ID가 "content"인 웹 요소에서 발견된 콘텐츠를 해석하여 상태를 초기화합니다. DOM 파서 메커니즘을 사용하며, 이는 스키마에서 제공된 정보를 사용하여 어떤 DOM 노드가 해당 스키마의 어떤 요소에 해당하는지 알아냅니다:

```javascript
import { DOMParser } from "prosemirror-model";
import { EditorState } from "prosemirror-state";
import { schema } from "prosemirror-schema-basic";

let content = document.getElementById("content");
let state = EditorState.create({
  doc: DOMParser.fromSchema(schema).parse(content),
});
```

## 문서의 구조

ProseMirror는 콘텐츠 문서를 표현하기 위한 자체 데이터 구조를 정의합니다. 문서는 나머지 에디터가 구축되는 중심 요소이므로, 문서가 어떻게 작동하는지 이해하는 것이 중요합니다.

### 문서 구조 이해하기

ProseMirror 문서는 노드이며, 0개 이상의 자식 노드를 포함하는 프래그먼트를 가지고 있습니다.

이것은 재귀적이고 트리 형태라는 점에서 브라우저 DOM과 매우 유사합니다. 하지만 인라인 콘텐츠를 저장하는 방식에서 DOM과 다릅니다.

HTML에서 마크업이 있는 단락은 다음과 같이 트리로 표현됩니다:

```html
<p>
  This is <strong>strong text with <em>emphasis</em></strong>
</p>
```

반면 ProseMirror에서는 인라인 콘텐츠가 평평한 연속으로 모델링되며, 마크업이 노드에 메타데이터로 첨부됩니다:

```
This is [strong text with [emphasis]]
```

이것은 우리가 그러한 텍스트에 대해 생각하고 작업하는 방식과 더 잘 맞습니다. 트리의 경로가 아닌 문자 위치를 사용하여 단락의 위치를 나타낼 수 있게 하며, 복잡한 트리 조작을 수행하지 않고도 콘텐츠를 분할하거나 스타일을 변경하는 것과 같은 작업을 더 쉽게 수행할 수 있습니다.

이것은 또한 각 문서가 하나의 유효한 표현을 갖는다는 것을 의미합니다. 동일한 마크 세트를 가진 인접한 텍스트 노드는 항상 함께 결합되며, 빈 텍스트 노드는 허용되지 않습니다. 마크가 나타나는 순서는 스키마에 의해 지정됩니다.

따라서 ProseMirror 문서는 블록 노드의 트리이며, 대부분의 리프 노드는 텍스트를 포함하는 블록 노드인 텍스트블록입니다. 수평선이나 비디오 요소처럼 단순히 비어있는 리프 블록도 가질 수 있습니다.

노드 객체에는 문서에서 수행하는 역할을 반영하는 여러 속성이 있습니다:

- `isBlock`과 `isInline`은 해당 노드가 블록인지 인라인 노드인지 알려줍니다.
- `inlineContent`는 콘텐츠로 인라인 노드를 기대하는 노드에 대해 참입니다.
- `isTextblock`은 인라인 콘텐츠를 가진 블록 노드에 대해 참입니다.
- `isLeaf`는 노드가 어떤 콘텐츠도 허용하지 않음을 알려줍니다.

따라서 일반적인 "단락" 노드는 텍스트블록이며, 인용구는 콘텐츠가 다른 블록으로 구성된 블록 요소일 수 있습니다. 텍스트, 줄바꿈, 인라인 이미지는 인라인 리프 노드이며, 수평선 노드는 블록 리프 노드의 예입니다.

스키마는 어디에 무엇이 나타날 수 있는지에 대해 더 정확한 제약을 지정할 수 있습니다. 즉, 노드가 블록 콘텐츠를 허용한다고 해서 모든 블록 노드를 콘텐츠로 허용한다는 의미는 아닙니다.

### 정체성과 영속성

DOM 트리와 ProseMirror 문서 간의 또 다른 중요한 차이점은 노드를 나타내는 객체가 동작하는 방식입니다. DOM에서 노드는 정체성을 가진 변경 가능한 객체이므로, 노드는 하나의 부모 노드에만 나타날 수 있으며, 업데이트될 때 노드 객체가 변경됩니다.

반면 ProseMirror에서 노드는 단순히 값이며, 숫자 3을 나타내는 값처럼 취급해야 합니다. 3은 여러 데이터 구조에 동시에 나타날 수 있으며, 현재 속한 데이터 구조에 대한 연결이 없고, 1을 더하면 원래의 3을 변경하지 않고 새 값인 4를 얻습니다.

ProseMirror 문서의 조각들도 마찬가지입니다. 변경되지 않지만, 문서의 수정된 조각을 계산하기 위한 시작 값으로 사용될 수 있습니다. 어떤 데이터 구조의 일부인지 알지 못하지만, 여러 구조의 일부가 될 수 있으며, 심지어 단일 구조에서 여러 번 나타날 수도 있습니다. 이들은 상태를 가진 객체가 아닌 값입니다.

이것은 문서를 업데이트할 때마다 새로운 문서 값을 얻는다는 것을 의미합니다. 그 문서 값은 원래 문서 값과 변경되지 않은 모든 하위 노드를 공유하므로, 생성하는 데 비교적 저렴합니다.

이것은 여러 가지 장점이 있습니다. 업데이트 중에 에디터가 유효하지 않은 중간 상태에 있을 수 없게 합니다. 새 문서를 가진 새 상태가 즉시 교체될 수 있기 때문입니다. 또한 값이 계속 변경된다면 정말 어려운 수학적 방식으로 문서에 대해 추론하는 것을 더 쉽게 만듭니다. 이것은 공동 편집을 가능하게 하고, ProseMirror가 화면에 마지막으로 그린 문서와 현재 문서를 비교하여 매우 효율적인 DOM 업데이트 알고리즘을 실행할 수 있게 합니다.

이러한 노드들은 일반 JavaScript 객체로 표현되고, 명시적으로 속성을 동결하는 것은 성능을 저해하기 때문에, 실제로 이들을 변경하는 것이 가능합니다. 하지만 이렇게 하는 것은 지원되지 않으며, 문제가 발생할 것입니다. 이들은 거의 항상 여러 데이터 구조 간에 공유되기 때문입니다. 따라서 주의하세요! 그리고 이것은 노드 속성을 저장하는 데 사용되는 객체나 프래그먼트의 자식 노드 배열과 같이 노드 객체의 일부인 배열과 일반 객체에도 적용된다는 점에 유의하세요.

### 데이터 구조 살펴보기

문서의 객체 구조는 다음과 같이 보입니다:

```
Node
├─ type: NodeType
├─ content: Fragment
│   └─ [Node, Node, ...]
├─ attrs: Object
└─ marks: [
    Mark
    ├─ type: MarkType
    └─ attrs: Object
    , ...]
```

각 노드는 `Node` 클래스의 인스턴스로 표현됩니다. 노드는 타입으로 태그가 지정되며, 타입은 노드의 이름, 유효한 속성 등을 알고 있습니다. 노드 타입(및 마크 타입)은 스키마당 한 번 생성되며, 자신이 속한 스키마를 알고 있습니다.

노드의 콘텐츠는 노드의 연속을 보유하는 `Fragment`의 인스턴스에 저장됩니다. 콘텐츠가 없거나 허용하지 않는 노드에 대해서도 이 필드는 채워집니다(공유되는 빈 프래그먼트로).

일부 노드 타입은 속성을 허용하며, 이는 각 노드와 함께 저장되는 추가 값입니다. 예를 들어, 이미지 노드는 이것을 사용하여 대체 텍스트와 이미지의 URL을 저장할 수 있습니다.

또한, 인라인 노드는 활성 마크 세트를 가집니다. 강조나 링크와 같은 것들이며, 이는 `Mark` 인스턴스의 배열로 표현됩니다.

완전한 문서는 단지 노드입니다. 문서 콘텐츠는 최상위 노드의 자식 노드로 표현됩니다. 일반적으로 일련의 블록 노드를 포함하며, 그 중 일부는 인라인 콘텐츠를 포함하는 텍스트블록일 수 있습니다. 하지만 최상위 노드 자체도 텍스트블록일 수 있으므로, 문서가 인라인 콘텐츠만 포함할 수 있습니다.

어떤 종류의 노드가 어디에 허용되는지는 문서의 스키마에 의해 결정됩니다. 프로그래밍 방식으로 노드를 만들려면 스키마를 통해야 하며, 예를 들어 `node` 및 `text` 메서드를 사용합니다.

```javascript
import { schema } from "prosemirror-schema-basic";

let doc = schema.node("doc", null, [
  schema.node("paragraph", null, [schema.text("One.")]),
  schema.node("horizontal_rule"),
  schema.node("paragraph", null, [schema.text("Two!")]),
]);
```

## 문서 내 위치 찾기 (인덱싱)

ProseMirror에서 문서 내 위치를 찾는 방법은 두 가지가 있습니다. 트리 구조로 다루거나, 평평한 토큰 연속으로 다룰 수 있습니다.

첫 번째 방법은 DOM에서 하는 것과 비슷합니다. 개별 노드와 상호작용하고, `child` 메서드와 `childCount`를 사용하여 자식 노드에 직접 접근하며, 문서를 스캔하는 재귀 함수를 작성할 수 있습니다(모든 노드를 보기만 원한다면 `descendants` 또는 `nodesBetween`을 사용하세요).

두 번째 방법은 문서의 특정 위치를 다룰 때 더 유용합니다. 모든 문서 위치를 정수(토큰 연속의 인덱스)로 나타낼 수 있게 해줍니다. 이러한 토큰은 실제로 메모리에 객체로 존재하지 않고 단지 카운팅 규칙일 뿐이지만, 문서의 트리 형태와 각 노드가 자신의 크기를 알고 있다는 사실이 위치별 접근을 효율적으로 만드는 데 활용됩니다.

- 문서의 시작, 첫 번째 콘텐츠 바로 앞은 위치 0입니다.
- 리프 노드가 아닌 노드(즉, 콘텐츠를 지원하는 노드)에 들어가거나 나가는 것은 하나의 토큰으로 계산됩니다. 따라서 문서가 단락으로 시작하면, 해당 단락의 시작은 위치 1로 계산됩니다.
- 텍스트 노드의 각 문자는 하나의 토큰으로 계산됩니다. 따라서 문서 시작 부분의 단락이 "hi"라는 단어를 포함하면, 위치 2는 "h" 뒤, 위치 3은 "i" 뒤, 위치 4는 전체 단락 뒤입니다.
- 콘텐츠를 허용하지 않는 리프 노드(예: 이미지)도 단일 토큰으로 계산됩니다.

따라서 HTML로 표현하면 다음과 같은 문서가 있다면:

```html
<p>One</p>
<blockquote>
  <p>Two<img src="..." /></p>
</blockquote>
```

위치가 있는 토큰 연속은 다음과 같습니다:

```
     0   1 2 3 4   5
     <p> O n e </p>
5   6            7 8 9 10    11  12         13
<blockquote> <p> T w o <img> </p> </blockquote>
```

각 노드에는 전체 노드의 크기를 제공하는 `nodeSize` 속성이 있으며, `.content.size`에 접근하여 노드 콘텐츠의 크기를 얻을 수 있습니다. 외부 문서 노드의 경우, 열림 및 닫힘 토큰은 문서의 일부로 간주되지 않습니다(문서 외부에 커서를 놓을 수 없기 때문입니다). 따라서 문서의 크기는 `doc.nodeSize`가 아닌 `doc.content.size`입니다.

이러한 위치를 수동으로 해석하는 것은 상당한 계산을 포함합니다. `Node.resolve`를 호출하여 위치에 대한 더 자세한 데이터 구조를 얻을 수 있습니다. 이 데이터 구조는 위치의 부모 노드가 무엇인지, 해당 부모로의 오프셋이 무엇인지, 부모가 어떤 조상을 가지고 있는지 등을 알려줍니다.

자식 인덱스(`childCount`에 따른), 문서 전체 위치, 그리고 노드 로컬 오프셋(때때로 현재 처리 중인 노드로의 위치를 나타내기 위해 재귀 함수에서 사용됨)을 구별하도록 주의하세요.

## 슬라이스 이해하기

복사-붙여넣기 및 드래그 앤 드롭과 같은 작업을 처리하려면 문서의 슬라이스, 즉 두 위치 사이의 콘텐츠에 대해 이야기할 수 있어야 합니다. 이러한 슬라이스는 시작 또는 끝 부분의 일부 노드가 '열려' 있을 수 있다는 점에서 완전한 노드나 프래그먼트와 다릅니다.

예를 들어, 한 단락의 중간에서 다음 단락의 중간까지 선택하면, 선택한 슬라이스에는 두 개의 단락이 있으며, 첫 번째는 시작 부분에서 열려있고, 두 번째는 끝 부분에서 열려있습니다. 반면에 단락을 노드 선택하면, 닫힌 노드를 선택한 것입니다.

이러한 열린 노드의 콘텐츠가 노드의 전체 콘텐츠로 처리되면 스키마 제약을 위반할 수 있습니다. 일부 필수 노드가 슬라이스 외부에 떨어졌기 때문입니다.

`Slice` 데이터 구조는 이러한 슬라이스를 나타내는 데 사용됩니다. 양쪽의 열린 깊이와 함께 프래그먼트를 저장합니다. 노드의 `slice` 메서드를 사용하여 문서에서 슬라이스를 잘라낼 수 있습니다.

```javascript
let slice1 = doc.slice(0, 3);
console.log(slice1.openStart, slice1.openEnd);
let slice2 = doc.slice(1, 5);
console.log(slice2.openStart, slice2.openEnd);
```

## 문서 변경하기

노드와 프래그먼트는 영속적이므로, 절대 변경해서는 안 됩니다. 문서(또는 노드, 또는 프래그먼트)에 대한 참조를 가지고 있다면, 그 객체는 동일하게 유지됩니다.

대부분의 경우 변환을 사용하여 문서를 업데이트할 것이며, 노드를 직접 건드릴 필요가 없습니다. 이들은 또한 문서가 에디터 상태의 일부일 때 필요한 변경 기록을 남깁니다.

문서를 '수동으로' 업데이트된 버전을 만들고 싶은 경우, `Node` 및 `Fragment` 타입에 사용 가능한 몇 가지 도우미 메서드가 있습니다. 전체 문서의 업데이트된 버전을 만들려면, 일반적으로 문서의 특정 범위를 새 콘텐츠의 슬라이스로 교체하는 `Node.replace`를 사용하고 싶을 것입니다. 노드를 얕게 업데이트하려면, 새 콘텐츠로 비슷한 노드를 만드는 `copy` 메서드를 사용할 수 있습니다. 프래그먼트도 `replaceChild` 또는 `append`와 같은 다양한 업데이트 메서드를 가지고 있습니다.

## 스키마 정의하기

각 ProseMirror 문서에는 연결된 스키마가 있습니다. 스키마는 문서에 나타날 수 있는 노드의 종류와 중첩 방식을 설명합니다. 예를 들어, 최상위 노드가 하나 이상의 블록을 포함할 수 있고, 단락 노드가 임의의 수의 인라인 노드를 포함할 수 있으며, 임의의 마크가 적용될 수 있다고 지정할 수 있습니다.

기본 스키마가 포함된 패키지가 있지만, ProseMirror의 장점은 자신만의 스키마를 정의할 수 있다는 것입니다.

### 노드 타입 정의하기

문서의 모든 노드에는 의미론적 의미와 속성(예: 에디터에서 렌더링되는 방식)을 나타내는 타입이 있습니다.

스키마를 정의할 때, 그 안에 나타날 수 있는 노드 타입을 나열하고, 각각을 스펙 객체로 설명합니다:

```javascript
const trivialSchema = new Schema({
  nodes: {
    doc: { content: "paragraph+" },
    paragraph: { content: "text*" },
    text: { inline: true },
  },
});
```

이것은 문서가 하나 이상의 단락을 포함할 수 있고, 각 단락이 임의의 양의 텍스트를 포함할 수 있는 스키마를 정의합니다.

모든 스키마는 최소한 최상위 노드 타입(기본적으로 "doc"이라는 이름이지만 설정할 수 있습니다)과 텍스트 콘텐츠를 위한 "text" 타입을 정의해야 합니다.

인라인으로 계산되는 노드는 `inline` 속성으로 이를 선언해야 합니다(정의상 인라인인 text 타입의 경우 생략할 수 있습니다).

### 콘텐츠 표현식 작성하기

예제 스키마의 `content` 필드에 있는 문자열을 콘텐츠 표현식이라고 합니다. 이들은 이 노드 타입에 대해 어떤 자식 노드 연속이 유효한지 제어합니다.

예를 들어, "하나의 단락"을 위해 "paragraph"라고 말할 수 있고, "하나 이상의 단락"을 표현하기 위해 "paragraph+"라고 할 수 있습니다. 마찬가지로, "paragraph\*"는 "0개 이상의 단락"을 의미하고 "caption?"은 "0개 또는 1개의 캡션 노드"를 의미합니다. 정규 표현식과 비슷한 범위도 사용할 수 있습니다. 예를 들어 노드 이름 뒤에 `{2}`("정확히 2개"), `{1, 5}`("1개에서 5개") 또는 `{2,}`("2개 이상")를 사용할 수 있습니다.

이러한 표현식을 결합하여 연속을 만들 수 있습니다. 예를 들어 "heading paragraph+"는 '먼저 제목, 그 다음 하나 이상의 단락'을 의미합니다. 파이프 `|` 연산자를 사용하여 두 표현식 간의 선택을 나타낼 수도 있습니다. 예를 들어 "(paragraph | blockquote)+"와 같이 말입니다.

일부 요소 타입 그룹은 스키마에서 여러 번 나타날 것입니다. 예를 들어 최상위 수준뿐만 아니라 인용구 내부에 중첩될 수 있는 "블록" 노드의 개념이 있을 수 있습니다. 노드 스펙에 `group` 속성을 제공하여 노드 그룹을 만들 수 있으며, 그런 다음 표현식에서 해당 그룹을 이름으로 참조할 수 있습니다.

```javascript
const groupSchema = new Schema({
  nodes: {
    doc: { content: "block+" },
    paragraph: { group: "block", content: "text*" },
    blockquote: { group: "block", content: "block+" },
    text: {},
  },
});
```

여기서 "block+"는 "(paragraph | blockquote)+"와 동등합니다.

블록 콘텐츠를 가진 노드(위의 예에서 "doc" 및 "blockquote"와 같은)에서는 항상 최소한 하나의 자식 노드를 요구하는 것이 권장됩니다. 브라우저가 비어있을 때 노드를 완전히 축소하여 편집하기가 상당히 어렵게 만들기 때문입니다.

or-표현식에서 노드가 나타나는 순서는 중요합니다. 예를 들어 교체 단계 이후 문서가 여전히 스키마를 준수하는지 확인하기 위해 필수가 아닌 노드에 대한 기본 인스턴스를 만들 때, 표현식의 첫 번째 타입이 사용됩니다. 그것이 그룹이면, 그룹의 첫 번째 타입(노드 맵에서 그룹 멤버가 나타나는 순서에 의해 결정됨)이 사용됩니다. 예제 스키마에서 "paragraph"와 "blockquote"의 위치를 바꾸면, 에디터가 블록 노드를 만들려고 하자마자 무한 루프가 발생할 것입니다. "blockquote" 노드를 만들 것이고, 그 콘텐츠는 최소한 하나의 블록을 요구하므로, 다시 "blockquote"를 콘텐츠로 만들려고 시도하는 식입니다.

라이브러리의 모든 노드 조작 함수가 유효한 콘텐츠를 다루고 있는지 확인하는 것은 아닙니다. 변환과 같은 상위 수준 개념은 확인하지만, 원시 노드 생성 메서드는 일반적으로 확인하지 않고 대신 제공되는 입력이 합리적이라는 책임을 호출자에게 둡니다. 슬라이스의 가장자리에서 '열려' 있는 노드의 경우, 이것은 심지어 합리적입니다. 별도의 `createChecked` 메서드와, 특정 노드의 콘텐츠가 유효한지 주장하는 데 사용할 수 있는 사후 `check` 메서드가 있습니다.

### 마크 정의하기

마크는 인라인 콘텐츠에 추가 스타일링이나 기타 정보를 추가하는 데 사용됩니다. 스키마는 허용하는 모든 마크 타입을 스키마에 선언해야 합니다. 마크 타입은 노드 타입과 매우 비슷한 객체로, 마크 객체를 태그하고 그에 대한 추가 정보를 제공하는 데 사용됩니다.

기본적으로 인라인 콘텐츠가 있는 노드는 스키마에 정의된 모든 마크가 자식에 적용되도록 허용합니다. 노드 스펙의 `marks` 속성으로 이를 설정할 수 있습니다.

다음은 단락의 텍스트에는 강조 및 이탤릭 마크를 지원하지만 제목에는 지원하지 않는 간단한 스키마입니다:

```javascript
const markSchema = new Schema({
  nodes: {
    doc: { content: "block+" },
    paragraph: { group: "block", content: "text*", marks: "_" },
    heading: { group: "block", content: "text*", marks: "" },
    text: { inline: true },
  },
  marks: {
    strong: {},
    em: {},
  },
});
```

마크 세트는 마크 이름 또는 마크 그룹의 공백으로 구분된 문자열로 해석됩니다. "\_"는 모든 마크를 의미하는 와일드카드로 작동하며, 빈 문자열은 빈 세트에 해당합니다.

### 속성 정의하기

문서 스키마는 각 노드 또는 마크가 어떤 속성을 가지는지도 정의합니다. 노드 타입이 저장되어야 할 추가 노드별 정보(예: 제목 노드의 레벨)를 요구하는 경우, 속성으로 처리하는 것이 가장 좋습니다.

속성 세트는 미리 정의된(노드 또는 마크당) 속성 세트를 보유하는 일반 객체로 표현되며, JSON으로 변환 가능한 값을 보유합니다. 허용하는 속성을 지정하려면, 노드 또는 마크 스펙에서 선택적 `attrs` 필드를 사용합니다.

```javascript
heading: {
  content: "text*",
  attrs: {level: {default: 1}}
}
```

이 스키마에서 `heading` 노드의 모든 인스턴스는 `.attrs.level` 아래에 `level` 속성을 갖습니다. 노드가 생성될 때 지정되지 않으면 기본값이 1이 됩니다.

속성에 기본값을 제공하지 않으면, 해당 속성을 지정하지 않고 그러한 노드를 만들려고 할 때 오류가 발생합니다.

이것은 또한 라이브러리가 변환 중에 또는 `createAndFill`을 호출할 때 스키마 제약을 만족시키기 위한 채움으로 그러한 노드를 생성할 수 없게 만듭니다. 이것이 스키마의 필수 위치에 그러한 노드를 놓을 수 없는 이유입니다. 스키마 제약을 강제할 수 있으려면, 에디터는 누락된 조각을 채우기 위해 빈 노드를 생성할 수 있어야 합니다.

### 직렬화 및 파싱

브라우저에서 편집할 수 있으려면, 문서 노드를 브라우저 DOM으로 표현할 수 있어야 합니다. 가장 쉬운 방법은 노드 스펙의 `toDOM` 필드를 사용하여 스키마에 각 노드의 DOM 표현에 대한 정보를 포함시키는 것입니다.

이 필드는 노드를 인수로 호출될 때 해당 노드에 대한 DOM 구조의 설명을 반환하는 함수를 보유해야 합니다. 이것은 직접 DOM 노드이거나 이를 설명하는 배열일 수 있습니다. 예를 들어:

```javascript
const schema = new Schema({
  nodes: {
    doc: { content: "paragraph+" },
    paragraph: {
      content: "text*",
      toDOM(node) {
        return ["p", 0];
      },
    },
    text: {},
  },
});
```

표현식 `["p", 0]`은 단락이 HTML `<p>` 태그로 렌더링된다고 선언합니다. 0은 콘텐츠가 렌더링되어야 하는 '구멍'입니다. 태그 이름 뒤에 HTML 속성이 있는 객체를 포함할 수도 있습니다. 예를 들어 `["div", {class: "c"}, 0]`과 같이 말입니다. 리프 노드는 콘텐츠가 없으므로 DOM 표현에 구멍이 필요하지 않습니다.

마크 스펙은 비슷한 `toDOM` 메서드를 허용하지만, 콘텐츠를 직접 감싸는 단일 태그로 렌더링해야 하므로, 콘텐츠는 항상 반환된 노드에 직접 들어가며 구멍을 지정할 필요가 없습니다.

또한 종종 DOM 데이터에서 문서를 파싱해야 합니다. 예를 들어 사용자가 에디터에 무언가를 붙여넣거나 드래그할 때입니다. model 모듈도 이를 위한 기능과 함께 제공되며, `parseDOM` 속성으로 스키마에 직접 파싱 정보를 포함하는 것을 권장합니다.

이것은 특정 노드 또는 마크에 매핑되는 DOM 구조를 설명하는 파스 규칙 배열을 나열할 수 있습니다. 예를 들어, 기본 스키마는 emphasis 마크에 대해 다음을 가지고 있습니다:

```javascript
parseDOM: [{ tag: "em" }, { tag: "i" }, { style: "font-style=italic" }];
```

파스 규칙에서 `tag`에 주어진 값은 CSS 선택자일 수 있으므로, "div.myclass"와 같은 것도 할 수 있습니다. 마찬가지로, `style`은 인라인 CSS 스타일과 일치합니다.

스키마가 `parseDOM` 주석을 포함하면, `DOMParser.fromSchema`로 그에 대한 `DOMParser` 객체를 만들 수 있습니다. 이것은 에디터가 기본 클립보드 파서를 만드는 데 사용되지만, 재정의할 수도 있습니다.

문서에는 내장 JSON 직렬화 형식도 함께 제공됩니다. `toJSON`을 호출하여 안전하게 `JSON.stringify`에 전달할 수 있는 객체를 얻을 수 있으며, 스키마 객체에는 이 표현을 다시 문서로 파싱할 수 있는 `nodeFromJSON` 메서드가 있습니다.

### 스키마 확장하기

`Schema` 생성자에 전달된 `nodes` 및 `marks` 옵션은 일반 JavaScript 객체뿐만 아니라 `OrderedMap` 객체도 받습니다. 결과 스키마의 `spec.nodes` 및 `spec.marks` 속성은 항상 `OrderedMap`이며, 이는 추가 스키마의 기초로 사용될 수 있습니다.

이러한 맵은 업데이트된 버전을 편리하게 만들기 위한 여러 메서드를 지원합니다. 예를 들어 `schema.spec.nodes.remove("blockquote")`라고 말하여 `blockquote` 노드가 없는 노드 세트를 만들 수 있으며, 이는 새 스키마의 nodes 필드로 전달될 수 있습니다.

schema-list 모듈은 해당 모듈에서 내보낸 노드를 노드세트에 추가하기 위한 편의 메서드를 내보냅니다.

## 변환 이해하기

변환은 ProseMirror가 작동하는 방식의 핵심입니다. 트랜잭션의 기초를 형성하며, 히스토리 추적 및 공동 편집을 가능하게 하는 것입니다.

### 변환이 필요한 이유

왜 문서를 그냥 변경하고 끝낼 수 없을까요? 아니면 최소한 문서의 새 버전을 만들어서 에디터에 넣을 수 없을까요?

여러 가지 이유가 있습니다. 하나는 코드 명확성입니다. 불변 데이터 구조는 정말로 더 간단한 코드로 이어집니다. 하지만 변환 시스템이 하는 주요 일은 업데이트의 흔적을 남기는 것입니다. 이는 문서의 이전 버전에서 새 버전으로 가기 위해 취한 개별 단계를 나타내는 값의 형태입니다.

실행 취소 히스토리는 이러한 단계를 저장하고 사용자가 실행 취소하고자 할 경우 그 역을 적용하여 시간을 되돌릴 수 있습니다(ProseMirror는 선택적 실행 취소를 구현하며, 이는 단순히 이전 상태로 롤백하는 것보다 더 복잡합니다).

공동 편집 시스템은 이러한 단계를 다른 에디터에 보내고 필요한 경우 재정렬하여 모두가 같은 문서로 끝나도록 합니다.

더 일반적으로, 에디터 플러그인이 각 변경사항이 들어올 때 검사하고 반응하여 자신의 상태를 나머지 에디터 상태와 일관되게 유지할 수 있다는 것은 매우 유용합니다.

### 단계 이해하기

문서에 대한 업데이트는 업데이트를 설명하는 단계로 분해됩니다. 일반적으로 이들과 직접 작업할 필요는 없지만, 어떻게 작동하는지 아는 것은 유용합니다.

단계의 예로는 문서의 일부를 교체하는 `ReplaceStep`이나 특정 범위에 마크를 추가하는 `AddMarkStep`이 있습니다.

단계는 새 문서를 생성하기 위해 문서에 적용될 수 있습니다.

```javascript
console.log(myDoc.toString());
let step = new ReplaceStep(3, 5, Slice.empty);
let result = step.apply(myDoc);
console.log(result.doc.toString());
```

단계를 적용하는 것은 비교적 간단한 프로세스입니다. 스키마 제약을 보존하기 위해 노드를 삽입하거나 슬라이스를 맞게 변환하는 것과 같은 영리한 작업을 하지 않습니다. 즉, 단계를 적용하는 것이 실패할 수 있습니다. 예를 들어 노드의 여는 토큰만 삭제하려고 하면, 토큰이 불균형하게 되어 의미 있게 할 수 있는 것이 아닙니다. 이것이 `apply`가 새 문서 또는 오류 메시지를 보유하는 결과 객체를 반환하는 이유입니다.

일반적으로 도우미 함수가 단계를 생성하도록 하여 세부 사항에 대해 걱정할 필요가 없도록 합니다.

### 변환 작업하기

편집 액션은 하나 이상의 단계를 생성할 수 있습니다. 단계의 연속으로 작업하는 가장 편리한 방법은 `Transform` 객체(또는 전체 에디터 상태로 작업하는 경우, `Transform`의 하위 클래스인 `Transaction`)를 만드는 것입니다.

```javascript
let tr = new Transform(myDoc);
tr.delete(5, 7);
tr.split(5);
console.log(tr.doc.toString());
console.log(tr.steps.length);
```

대부분의 변환 메서드는 편리한 체이닝을 위해 변환 자체를 반환합니다(`tr.delete(5, 7).split(5)`와 같이 할 수 있습니다).

삭제 및 교체, 마크 추가 및 마크 제거, 분할, 결합, 들어올리기, 감싸기와 같은 트리 조작 등을 위한 변환 메서드가 있습니다.

### 매핑 이해하기

문서를 변경하면, 해당 문서를 가리키는 위치가 유효하지 않게 되거나 의미가 변경될 수 있습니다. 예를 들어, 문자를 삽입하면 해당 문자 이후의 모든 위치가 이제 이전 위치보다 한 토큰 앞을 가리킵니다. 마찬가지로, 문서의 모든 콘텐츠를 삭제하면 해당 콘텐츠를 가리키는 모든 위치가 이제 유효하지 않습니다.

문서 변경 간에 위치를 보존해야 하는 경우가 종종 있습니다. 예를 들어 선택 경계가 그렇습니다. 이를 돕기 위해, 단계는 문서에 단계를 적용하기 전후의 위치 간을 변환할 수 있는 맵을 제공할 수 있습니다.

```javascript
let step = new ReplaceStep(4, 6, Slice.empty);
let map = step.getMap();
console.log(map.map(8));
console.log(map.map(2));
```

Transform 객체는 `Mapping`이라는 추상화를 사용하여 일련의 단계 맵을 수집하고 한 번에 그것들을 통해 매핑할 수 있도록 하는 맵 세트를 자동으로 누적합니다.

```javascript
let tr = new Transform(myDoc);
tr.split(10);
tr.delete(2, 5);
console.log(tr.mapping.map(15));
console.log(tr.mapping.map(6));
console.log(tr.mapping.map(10));
```

특정 위치가 무엇으로 매핑되어야 하는지 완전히 명확하지 않은 경우가 있습니다. 위 예제의 마지막 줄을 고려해보세요. 위치 10은 노드를 분할한 지점을 정확히 가리키며, 두 개의 토큰을 삽입합니다. 삽입된 콘텐츠 이후의 위치로 매핑되어야 할까요, 아니면 그 앞에 있어야 할까요? 예제에서는 명백히 삽입된 토큰 이후로 이동했습니다.

하지만 때로는 다른 동작을 원하며, 이것이 단계 맵과 매핑의 `map` 메서드가 두 번째 매개변수 `bias`를 허용하는 이유입니다. 이를 -1로 설정하면 콘텐츠가 그 위에 삽입될 때 위치를 그대로 유지할 수 있습니다.

```javascript
console.log(tr.mapping.map(10, -1));
```

개별 단계가 작고 직관적인 것으로 정의되는 이유는 이러한 종류의 매핑이 가능하게 하고, 단계를 무손실 방식으로 역전시키며, 서로의 위치 맵을 통해 단계를 매핑하기 때문입니다.

### 리베이싱 이해하기

단계와 위치 맵으로 더 복잡한 작업을 할 때, 예를 들어 자신만의 변경 추적을 구현하거나 공동 편집과 어떤 기능을 통합할 때, 단계를 리베이스해야 하는 필요성에 부딪힐 수 있습니다.

이것이 필요하다고 확신할 때까지는 이를 공부하는 것을 원하지 않을 수 있습니다.

리베이싱은 간단한 경우, 동일한 문서로 시작하는 두 단계를 가져와서, 그 중 하나를 다른 것에 의해 생성된 문서에 적용할 수 있도록 변환하는 프로세스입니다. 의사 코드로:

```
stepA(doc) = docA
stepB(doc) = docB
stepB(docA) = 불일치!
rebase(stepB, mapA) = stepB'
stepB'(docA) = docAB
```

단계에는 매핑이 주어지면 전체 단계를 그것을 통해 매핑하는 `map` 메서드가 있습니다. 예를 들어 단계가 적용된 콘텐츠가 삭제된 경우와 같이 일부 단계가 더 이상 의미가 없을 때 실패할 수 있습니다. 하지만 성공하면, 새 문서를 가리키는 단계, 즉 매핑한 변경 이후의 문서를 가리키는 단계를 갖게 됩니다. 따라서 위의 예에서 `rebase(stepB, mapA)`는 단순히 `stepB.map(mapA)`를 호출할 수 있습니다.

다른 단계 체인에 대해 단계 체인을 리베이스하려고 할 때 상황이 더 복잡해집니다.

```
stepA2(stepA1(doc)) = docA
stepB2(stepB1(doc)) = docB
???(docA) = docAB
```

`stepB1`을 `stepA1` 다음 `stepA2`를 통해 매핑하여 `stepB1'`을 얻을 수 있습니다. 하지만 `stepB1(doc)`에 의해 생성된 문서에서 시작하고, 매핑된 버전이 `stepB1'(docA)`에 의해 생성된 문서에 적용되어야 하는 `stepB2`의 경우, 상황이 더 어려워집니다. 다음 맵 체인을 통해 매핑되어야 합니다:

```
rebase(stepB2, [invert(mapB1), mapA1, mapA2, mapB1'])
```

즉, 먼저 원래 문서로 돌아가기 위해 `stepB1`의 맵의 역을 통해, 그런 다음 `stepA1`과 `stepA2`를 적용하여 생성된 맵의 파이프라인을 통해, 마지막으로 `docA`에 `stepB1'`을 적용하여 생성된 맵을 통해 매핑됩니다.

`stepB3`이 있었다면, `invert(mapB2)`를 앞에 붙이고 끝에 `mapB2'`를 추가하여 그것에 대한 파이프라인을 얻습니다. 그리고 계속됩니다.

하지만 `stepB1`이 어떤 콘텐츠를 삽입하고, `stepB2`가 해당 콘텐츠에 무언가를 했다면, `stepB2`를 `invert(mapB1)`을 통해 매핑하는 것은 `null`을 반환할 것입니다. `stepB1`의 역이 적용되는 콘텐츠를 삭제하기 때문입니다. 하지만 이 콘텐츠는 나중에 파이프라인에서 `mapB1`에 의해 다시 도입됩니다. `Mapping` 추상화는 그 안의 맵 간의 역 관계를 포함하여 이러한 파이프라인을 추적하는 방법을 제공합니다. 위와 같은 상황에서 살아남도록 단계를 그것을 통해 매핑할 수 있습니다.

단계를 리베이스했더라도, 현재 문서에 여전히 유효하게 적용될 수 있다는 보장은 없습니다. 예를 들어, 단계가 마크를 추가하지만 다른 단계가 대상 콘텐츠의 부모 노드를 마크를 허용하지 않는 노드로 변경한 경우, 단계를 적용하려고 하면 실패할 것입니다. 이에 대한 적절한 응답은 일반적으로 단계를 삭제하는 것입니다.

## 에디터 상태 관리하기

에디터의 상태를 구성하는 것은 무엇일까요? 물론 문서가 있습니다. 그리고 현재 선택 영역도 있습니다. 그리고 마크를 비활성화하거나 활성화했지만 아직 해당 마크로 타이핑을 시작하지 않은 경우와 같이, 현재 마크 세트가 변경되었다는 사실을 저장할 방법이 필요합니다.

이들은 ProseMirror 상태의 세 가지 주요 구성 요소이며, 상태 객체에 `doc`, `selection`, `storedMarks`로 존재합니다.

```javascript
import { schema } from "prosemirror-schema-basic";
import { EditorState } from "prosemirror-state";

let state = EditorState.create({ schema });
console.log(state.doc.toString());
console.log(state.selection.from);
```

하지만 플러그인도 상태를 저장해야 할 수 있습니다. 예를 들어, 실행 취소 히스토리는 변경 이력을 유지해야 합니다. 이것이 활성 플러그인 세트도 상태에 저장되는 이유이며, 이러한 플러그인은 자신의 상태를 저장하기 위한 추가 슬롯을 정의할 수 있습니다.

### 선택 이해하기

ProseMirror는 여러 유형의 선택을 지원합니다(그리고 서드파티 코드가 새로운 선택 타입을 정의할 수 있도록 허용합니다). 선택은 `Selection` 클래스의(하위 클래스의) 인스턴스로 표현됩니다. 문서 및 기타 상태 관련 값과 마찬가지로, 이들은 불변입니다. 선택을 변경하려면, 새로운 선택 객체와 그것을 보유하는 새로운 상태를 만듭니다.

선택은 최소한 시작(`.from`)과 끝(`.to`)을 현재 문서를 가리키는 위치로 가집니다. 많은 선택 타입은 선택의 앵커(움직이지 않는) 측과 헤드(움직일 수 있는) 측을 구분하므로, 이들도 모든 선택 객체에 존재해야 합니다.

가장 일반적인 선택 타입은 일반 커서(앵커와 헤드가 동일할 때) 또는 선택된 텍스트에 사용되는 텍스트 선택입니다. 텍스트 선택의 두 끝점은 모두 인라인 위치에 있어야 합니다. 즉, 인라인 콘텐츠를 허용하는 노드를 가리켜야 합니다.

코어 라이브러리는 또한 단일 문서 노드가 선택되는 노드 선택을 지원하며, 예를 들어 노드를 Ctrl/Cmd-클릭할 때 얻게 됩니다. 이러한 선택은 노드 바로 앞의 위치에서 바로 뒤의 위치까지입니다.

### 트랜잭션 사용하기

일반적인 편집 중에, 새로운 상태는 이전 상태에서 파생됩니다. 새 문서를 로드하는 것과 같은 일부 상황에서는 완전히 새로운 상태를 만들고 싶을 수 있지만, 이것은 예외입니다.

상태 업데이트는 기존 상태에 트랜잭션을 적용하여 새 상태를 생성함으로써 발생합니다. 개념적으로, 이들은 한 번에 발생합니다. 이전 상태와 트랜잭션이 주어지면, 상태의 각 구성 요소에 대해 새로운 값이 계산되고, 이들이 새 상태 값에 함께 모입니다.

```javascript
let tr = state.tr;
console.log(tr.doc.content.size);
tr.insertText("hello");
let newState = state.apply(tr);
console.log(tr.doc.content.size);
```

`Transaction`은 `Transform`의 하위 클래스이며, 초기 문서에 단계를 적용하여 새 문서를 구축하는 방식을 상속합니다. 이에 더해, 트랜잭션은 선택 및 기타 상태 관련 구성 요소를 추적하고, `replaceSelection`과 같은 선택 관련 편의 메서드를 얻습니다.

트랜잭션을 만드는 가장 쉬운 방법은 에디터 상태 객체의 `tr` 게터를 사용하는 것입니다. 이것은 해당 상태를 기반으로 한 빈 트랜잭션을 만들며, 그런 다음 단계 및 기타 업데이트를 추가할 수 있습니다.

```javascript
let tr = state.tr;
console.log(tr.selection.from);
tr.delete(6, 8);
console.log(tr.selection.from);
tr.setSelection(TextSelection.create(tr.doc, 3));
console.log(tr.selection.from);
```

기본적으로, 이전 선택은 각 단계를 통해 매핑되어 새로운 선택을 생성하지만, `setSelection`을 사용하여 명시적으로 새 선택을 설정할 수 있습니다.

마찬가지로, 활성 마크 세트는 문서 또는 선택 변경 후 자동으로 지워지며, `setStoredMarks` 또는 `ensureMarks` 메서드를 사용하여 설정할 수 있습니다.

마지막으로, `scrollIntoView` 메서드를 사용하여 다음에 상태가 그려질 때 선택이 뷰에 스크롤되도록 할 수 있습니다. 대부분의 사용자 액션에 대해 이것을 하고 싶을 것입니다.

`Transform` 메서드처럼, 많은 `Transaction` 메서드는 편리한 체이닝을 위해 트랜잭션 자체를 반환합니다.

### 플러그인 활용하기

새 상태를 만들 때, 사용할 플러그인 배열을 제공할 수 있습니다. 이들은 상태와 그로부터 파생된 모든 상태에 저장되며, 트랜잭션이 적용되는 방식과 이 상태를 기반으로 하는 에디터가 동작하는 방식 모두에 영향을 미칠 수 있습니다.

플러그인은 `Plugin` 클래스의 인스턴스이며, 다양한 기능을 모델링할 수 있습니다. 가장 간단한 것은 에디터 뷰에 일부 속성을 추가하여, 예를 들어 특정 이벤트에 응답합니다. 더 복잡한 것은 에디터에 새로운 상태를 추가하고 트랜잭션을 기반으로 업데이트할 수 있습니다.

플러그인을 만들 때, 동작을 지정하는 객체를 전달합니다:

```javascript
let myPlugin = new Plugin({
  props: {
    handleKeyDown(view, event) {
      console.log("키가 눌렸습니다!");
      return false;
    },
  },
});

let state = EditorState.create({ schema, plugins: [myPlugin] });
```

플러그인이 자체 상태 슬롯이 필요한 경우, 이는 `state` 속성으로 정의됩니다:

```javascript
let transactionCounter = new Plugin({
  state: {
    init() {
      return 0;
    },
    apply(tr, value) {
      return value + 1;
    },
  },
});

function getTransactionCount(state) {
  return transactionCounter.getState(state);
}
```

예제의 플러그인은 상태에 적용된 트랜잭션의 수를 단순히 세는 매우 간단한 상태 조각을 정의합니다. 도우미 함수는 플러그인의 `getState` 메서드를 사용하며, 이는 전체 에디터 상태 객체에서 플러그인 상태를 가져오는 데 사용될 수 있습니다.

에디터 상태는 영속적(불변) 객체이고, 플러그인 상태는 해당 객체의 일부이므로, 플러그인 상태 값은 불변이어야 합니다. 즉, `apply` 메서드는 변경해야 하는 경우 이전 값을 변경하는 것이 아니라 새 값을 반환해야 하며, 다른 코드가 이를 변경해서는 안 됩니다.

플러그인이 트랜잭션에 추가 정보를 추가하는 것이 종종 유용합니다. 예를 들어, 실행 취소 히스토리는 실제 실행 취소를 수행할 때 결과 트랜잭션을 표시하여, 플러그인이 이를 볼 때 일반적으로 변경 사항으로 수행하는 작업(실행 취소 스택에 추가) 대신 특별히 처리하여, 실행 취소 스택의 최상위 항목을 제거하고 이 트랜잭션을 재실행 스택에 추가합니다.

이를 위해, 트랜잭션은 메타데이터를 첨부할 수 있도록 허용합니다. 트랜잭션 카운터 플러그인을 업데이트하여 표시된 트랜잭션을 세지 않도록 할 수 있습니다:

```javascript
let transactionCounter = new Plugin({
  state: {
    init() {
      return 0;
    },
    apply(tr, value) {
      if (tr.getMeta(transactionCounter)) return value;
      else return value + 1;
    },
  },
});

function markAsUncounted(tr) {
  tr.setMeta(transactionCounter, true);
}
```

메타데이터 속성의 키는 문자열일 수 있지만, 이름 충돌을 피하기 위해 플러그인 객체를 사용하는 것을 권장합니다. 라이브러리에 의해 의미가 부여된 일부 문자열 키가 있습니다. 예를 들어 `"addToHistory"`를 false로 설정하여 트랜잭션이 실행 취소 가능하지 않도록 할 수 있으며, 붙여넣기를 처리할 때 에디터 뷰는 결과 트랜잭션에 `"paste"` 속성을 true로 설정합니다.

## 뷰 컴포넌트

ProseMirror 에디터 뷰는 에디터 상태를 사용자에게 표시하고, 사용자가 편집 작업을 수행할 수 있게 하는 사용자 인터페이스 컴포넌트입니다.

코어 뷰 컴포넌트에서 다루는 편집 작업의 범위는 다소 제한적입니다. 타이핑, 클릭, 복사, 붙여넣기, 드래그와 같은 편집 화면과의 직접적인 상호작용을 처리하지만, 그 이상은 많지 않습니다. 이것은 메뉴 표시나 심지어 전체 키보드 단축키 세트 제공과 같은 것들이 코어 뷰 컴포넌트의 책임 밖에 있으며, 플러그인을 통해 배치되어야 함을 의미합니다.

### 편집 가능한 DOM

브라우저는 DOM의 일부 부분을 편집 가능하도록 지정할 수 있게 하며, 이는 그 안에 포커스와 선택을 허용하고 타이핑할 수 있게 하는 효과가 있습니다. 뷰는 문서의 DOM 표현을 만들고(기본적으로 스키마의 toDOM 메서드를 사용하여) 편집 가능하게 만듭니다.

편집 가능한 요소가 포커스될 때, ProseMirror는 DOM 선택이 에디터 상태의 선택에 해당하는지 확인합니다.

또한 많은 DOM 이벤트에 대한 이벤트 핸들러를 등록하여, 이벤트를 적절한 트랜잭션으로 변환합니다. 예를 들어, 붙여넣기할 때 붙여넣은 콘텐츠는 ProseMirror 문서 슬라이스로 파싱되고, 그런 다음 문서에 삽입됩니다.

많은 이벤트는 그대로 통과되고, 그런 다음에야 ProseMirror의 데이터 모델 관점에서 재해석됩니다. 예를 들어 브라우저는 커서와 선택 배치에 상당히 능숙합니다(양방향 텍스트를 고려하면 정말 어려운 문제입니다). 따라서 대부분의 커서 이동 관련 키와 마우스 동작은 브라우저에 의해 처리되며, 그 후 ProseMirror는 현재 DOM 선택이 어떤 종류의 텍스트 선택에 해당하는지 확인합니다. 해당 선택이 현재 선택과 다른 경우, 선택을 업데이트하는 트랜잭션이 전달됩니다.

타이핑조차도 일반적으로 브라우저에 맡겨집니다. 이것을 간섭하면 맞춤법 검사, 일부 모바일 인터페이스의 자동 대문자화 및 기타 네이티브 기능을 방해하는 경향이 있기 때문입니다. 브라우저가 DOM을 업데이트하면, 에디터는 이를 인지하고 문서의 변경된 부분을 다시 파싱하여 차이를 트랜잭션으로 변환합니다.

### 데이터 흐름 이해하기

따라서 에디터 뷰는 주어진 에디터 상태를 표시하고, 무언가가 발생하면 트랜잭션을 만들어 전파합니다. 이 트랜잭션은 일반적으로 새 상태를 만드는 데 사용되며, `updateState` 메서드를 사용하여 뷰에 제공됩니다.

```
DOM 이벤트
   ↗↘
  ↖↙
새 EditorState
```

이것은 명령형 이벤트 핸들러의 집합을 가진 전통적인 접근 방식(JavaScript 세계에서)과는 대조적으로, 훨씬 더 복잡한 데이터 흐름의 웹을 만드는 경향이 있는 간단하고 순환적인 데이터 흐름을 만듭니다.

트랜잭션이 전달될 때 `dispatchTransaction` prop으로 트랜잭션을 '가로채서' 이 순환적 데이터 흐름을 더 큰 순환에 연결하는 것이 가능합니다. Redux와 비슷한 아키텍처와 같이 전체 앱이 이러한 데이터 흐름 모델을 사용하는 경우, ProseMirror의 트랜잭션을 메인 액션 전달 순환에 통합하고 ProseMirror의 상태를 애플리케이션 '스토어'에 유지할 수 있습니다.

```javascript
let appState = {
  editor: EditorState.create({ schema }),
  score: 0,
};

let view = new EditorView(document.body, {
  state: appState.editor,
  dispatchTransaction(transaction) {
    update({ type: "EDITOR_TRANSACTION", transaction });
  },
});

function update(event) {
  if (event.type == "EDITOR_TRANSACTION")
    appState.editor = appState.editor.apply(event.transaction);
  else if (event.type == "SCORE_POINT") appState.score++;
  draw();
}

function draw() {
  document.querySelector("#score").textContent = appState.score;
  view.updateState(appState.editor);
}
```

### 효율적인 업데이트

`updateState`를 구현하는 한 가지 방법은 호출될 때마다 단순히 문서를 다시 그리는 것입니다. 하지만 큰 문서의 경우 정말 느릴 것입니다.

업데이트 시점에 뷰가 이전 문서와 새 문서 모두에 접근할 수 있으므로, 이들을 비교하고 변경되지 않은 노드에 해당하는 DOM 부분을 그대로 둘 수 있습니다. ProseMirror는 이를 수행하여, 일반적인 업데이트에 대해 매우 적은 작업을 수행할 수 있습니다.

타이핑된 텍스트에 해당하는 업데이트와 같은 일부 경우, 이미 브라우저 자체 편집 동작에 의해 DOM에 추가되었으므로, DOM과 상태가 일치하는지 확인하는 데 DOM 변경이 전혀 필요하지 않습니다. (이러한 트랜잭션이 취소되거나 어떤 식으로든 수정되면, 뷰는 DOM과 상태가 동기화된 상태로 유지되도록 DOM 변경을 취소합니다.)

마찬가지로, DOM 선택은 상태의 선택과 실제로 동기화되지 않을 때만 업데이트되어, 브라우저가 선택과 함께 유지하는 다양한 '숨겨진' 상태 조각을 방해하지 않습니다(예를 들어 짧은 줄을 지나 위아래로 화살표를 누를 때, 수평 위치가 다음 긴 줄에 들어갈 때 있던 곳으로 돌아가는 기능).

### Props 이해하기

'Props'는 React에서 가져온 유용하지만 다소 모호한 용어입니다. Props는 UI 컴포넌트에 대한 매개변수와 같습니다. 이상적으로, 컴포넌트가 받는 props 세트가 그 동작을 완전히 정의합니다.

```javascript
let view = new EditorView({
  state: myState,
  editable() {
    return false;
  },
  handleDoubleClick() {
    console.log("더블 클릭!");
  },
});
```

따라서, 현재 상태는 하나의 prop입니다. 다른 props의 값도 시간이 지남에 따라 변할 수 있지만, 컴포넌트를 제어하는 코드가 이를 업데이트하면, 컴포넌트 자체가 변경하지 않기 때문에 상태로 간주되지 않습니다. `updateState` 메서드는 단지 state prop을 업데이트하는 단축입니다.

플러그인도 props를 선언할 수 있지만, 뷰에 직접 제공될 수만 있는 `state`와 `dispatchTransaction`은 제외됩니다.

```javascript
function maxSizePlugin(max) {
  return new Plugin({
    props: {
      editable(state) {
        return state.doc.content.size < max;
      },
    },
  });
}
```

특정 prop이 여러 번 선언되면, 처리 방식은 prop에 따라 다릅니다. 일반적으로, 직접 제공된 props가 우선하며, 그 후 각 플러그인이 순서대로 차례를 얻습니다. `domParser`와 같은 일부 props의 경우, 발견된 첫 번째 값이 사용되고 다른 값은 무시됩니다. 이벤트를 처리했는지 여부를 나타내기 위해 boolean을 반환하는 핸들러 함수의 경우, true를 반환하는 첫 번째 것이 이벤트를 처리합니다. 마지막으로, `attributes`(편집 가능한 DOM 노드에 속성을 설정하는 데 사용될 수 있음)와 `decorations`(다음 섹션에서 다룰 것)와 같은 일부 props의 경우, 제공된 모든 값의 합집합이 사용됩니다.

### 데코레이션 활용하기

데코레이션은 뷰가 문서를 그리는 방식에 대한 일부 제어권을 제공합니다. `decorations` prop에서 값을 반환하여 생성되며, 세 가지 유형이 있습니다:

- 노드 데코레이션은 단일 노드의 DOM 표현에 스타일링 또는 기타 DOM 속성을 추가합니다.
- 위젯 데코레이션은 실제 문서의 일부가 아닌 DOM 노드를 특정 위치에 삽입합니다.
- 인라인 데코레이션은 노드 데코레이션과 매우 비슷하게 스타일링이나 속성을 추가하지만, 특정 범위의 모든 인라인 노드에 추가합니다.

데코레이션을 효율적으로 그리고 비교할 수 있으려면, 데코레이션 세트로 제공되어야 합니다(실제 문서의 트리 형태를 모방하는 데이터 구조). 정적 `create` 메서드를 사용하여 문서와 데코레이션 객체 배열을 제공하여 하나를 만듭니다:

```javascript
let purplePlugin = new Plugin({
  props: {
    decorations(state) {
      return DecorationSet.create(state.doc, [
        Decoration.inline(0, state.doc.content.size, {
          style: "color: purple",
        }),
      ]);
    },
  },
});
```

데코레이션이 많은 경우, 모든 다시 그리기마다 세트를 즉석에서 다시 만드는 것은 너무 비용이 많이 들 가능성이 높습니다. 이러한 경우, 데코레이션을 유지하는 권장 방법은 플러그인의 상태에 세트를 넣고, 변경 사항을 통해 매핑하고, 필요할 때만 변경하는 것입니다.

```javascript
let specklePlugin = new Plugin({
  state: {
    init(_, { doc }) {
      let speckles = [];
      for (let pos = 1; pos < doc.content.size; pos += 4)
        speckles.push(
          Decoration.inline(pos - 1, pos, { style: "background: yellow" })
        );
      return DecorationSet.create(doc, speckles);
    },
    apply(tr, set) {
      return set.map(tr.mapping, tr.doc);
    },
  },
  props: {
    decorations(state) {
      return specklePlugin.getState(state);
    },
  },
});
```

이 플러그인은 상태를 4번째 위치마다 노란색 배경 인라인 데코레이션을 추가하는 데코레이션 세트로 초기화합니다. 그다지 유용하지는 않지만, 검색 일치 항목이나 주석이 달린 영역을 강조 표시하는 것과 같은 사용 사례와 비슷합니다.

트랜잭션이 상태에 적용되면, 플러그인 상태의 `apply` 메서드는 데코레이션 세트를 앞으로 매핑하여, 데코레이션이 제자리에 유지되고 새 문서 형태에 '맞도록' 합니다. 매핑 메서드는(일반적인 로컬 변경의 경우) 데코레이션 세트의 트리 형태를 활용하여 효율적으로 만들어집니다. 변경 사항에 의해 실제로 영향을 받는 트리의 부분만 재구축하면 됩니다.

(실제 플러그인에서는, `apply` 메서드가 새 이벤트를 기반으로 데코레이션을 추가하거나 제거하는 곳이기도 합니다. 트랜잭션의 변경 사항을 검사하거나 트랜잭션에 첨부된 플러그인별 메타데이터를 기반으로 할 수 있습니다.)

마지막으로, `decorations` prop은 단순히 플러그인 상태를 반환하여, 데코레이션이 뷰에 표시되도록 합니다.

### 노드 뷰 사용하기

에디터 뷰가 문서를 그리는 방식에 영향을 미칠 수 있는 한 가지 방법이 더 있습니다. 노드 뷰는 문서의 개별 노드에 대한 일종의 소형 UI 컴포넌트를 정의할 수 있게 합니다. DOM을 렌더링하고, 업데이트되는 방식을 정의하고, 이벤트에 반응하기 위한 맞춤 코드를 작성할 수 있게 합니다.

```javascript
let view = new EditorView({
  state,
  nodeViews: {
    image(node) {
      return new ImageView(node);
    },
  },
});

class ImageView {
  constructor(node) {
    this.dom = document.createElement("img");
    this.dom.src = node.attrs.src;
    this.dom.addEventListener("click", (e) => {
      console.log("이미지를 클릭했습니다!");
      e.preventDefault();
    });
  }

  stopEvent() {
    return true;
  }
}
```

예제가 이미지 노드에 대해 정의하는 뷰 객체는 이벤트 핸들러가 추가된 이미지에 대한 자체 맞춤 DOM 노드를 만들고, `stopEvent` 메서드로 ProseMirror가 해당 DOM 노드에서 오는 이벤트를 무시해야 함을 선언합니다.

노드와의 상호작용이 문서의 실제 노드에 어떤 영향을 미치기를 원하는 경우가 많습니다. 하지만 노드를 변경하는 트랜잭션을 만들려면, 먼저 해당 노드가 어디에 있는지 알아야 합니다. 이를 돕기 위해, 노드 뷰는 문서에서 현재 위치를 조회하는 데 사용할 수 있는 게터 함수를 전달받습니다. 예제를 수정하여 노드를 클릭하면 이미지의 alt 텍스트를 입력하도록 요청하도록 해봅시다:

```javascript
let view = new EditorView({
  state,
  nodeViews: {
    image(node, view, getPos) {
      return new ImageView(node, view, getPos);
    },
  },
});

class ImageView {
  constructor(node, view, getPos) {
    this.dom = document.createElement("img");
    this.dom.src = node.attrs.src;
    this.dom.alt = node.attrs.alt;
    this.dom.addEventListener("click", (e) => {
      e.preventDefault();
      let alt = prompt("새 alt 텍스트:", "");
      if (alt)
        view.dispatch(
          view.state.tr.setNodeMarkup(getPos(), null, {
            src: node.attrs.src,
            alt,
          })
        );
    });
  }

  stopEvent() {
    return true;
  }
}
```

`setNodeMarkup`은 특정 위치의 노드에 대한 타입 또는 속성 세트를 변경하는 데 사용할 수 있는 메서드입니다. 예제에서는 `getPos`를 사용하여 이미지의 현재 위치를 찾고, 새 alt 텍스트로 새 속성 객체를 제공합니다.

노드가 업데이트될 때, 기본 동작은 외부 DOM 구조를 그대로 두고 자식을 새 자식 세트와 비교하여 필요에 따라 업데이트하거나 교체하는 것입니다. 노드 뷰는 맞춤 동작으로 이를 재정의할 수 있으며, 이를 통해 콘텐츠를 기반으로 단락의 클래스를 변경하는 것과 같은 작업을 할 수 있습니다.

```javascript
let view = new EditorView({
  state,
  nodeViews: {
    paragraph(node) {
      return new ParagraphView(node);
    },
  },
});

class ParagraphView {
  constructor(node) {
    this.dom = this.contentDOM = document.createElement("p");
    if (node.content.size == 0) this.dom.classList.add("empty");
  }

  update(node) {
    if (node.content.size > 0) this.dom.classList.remove("empty");
    else this.dom.classList.add("empty");
    return true;
  }
}
```

이미지는 콘텐츠가 없으므로, 이전 예제에서는 콘텐츠가 어떻게 렌더링될지 걱정할 필요가 없었습니다. 하지만 단락은 콘텐츠를 가지고 있습니다. 노드 뷰는 콘텐츠를 처리하는 두 가지 접근 방식을 지원합니다. ProseMirror 라이브러리가 관리하도록 하거나, 완전히 직접 관리할 수 있습니다. `contentDOM` 속성을 제공하면, 라이브러리는 노드의 콘텐츠를 그곳에 렌더링하고 콘텐츠 업데이트를 처리합니다. 제공하지 않으면, 콘텐츠는 에디터에 블랙박스가 되며, 어떻게 표시하고 사용자가 어떻게 상호작용하게 할지는 전적으로 여러분에게 달려 있습니다.

이 경우, 단락 콘텐츠가 일반 편집 가능한 텍스트처럼 동작하기를 원하므로, `contentDOM` 속성을 `dom` 속성과 동일하게 정의합니다. 콘텐츠가 외부 노드에 직접 렌더링되어야 하기 때문입니다.

마법은 `update` 메서드에서 일어납니다. 첫째, 이 메서드는 노드 뷰가 새 노드를 표시하도록 업데이트될 수 있는지 여부를 결정하는 책임이 있습니다. 불가능한 경우 false를 반환해야 합니다.

예제의 `update` 메서드는 새 노드의 콘텐츠에 따라 "empty" 클래스가 있거나 없는지 확인하고, true를 반환하여 업데이트가 성공했음을 나타냅니다(이 시점에서 노드의 콘텐츠가 업데이트됩니다).

## 명령 이해하기

ProseMirror 전문 용어에서, 명령은 사용자가 어떤 키 조합을 누르거나 메뉴와 상호작용하여 수행할 수 있는 편집 동작을 구현하는 함수입니다.

실용적인 이유로, 명령은 약간 복잡한 인터페이스를 가지고 있습니다. 간단한 형태로, 이들은 에디터 상태와 전달 함수(`EditorView.dispatch` 또는 트랜잭션을 받는 다른 함수)를 받고 boolean을 반환하는 함수입니다. 매우 간단한 예는 다음과 같습니다:

```javascript
function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false;
  dispatch(state.tr.deleteSelection());
  return true;
}
```

명령이 적용 가능하지 않을 때는 false를 반환하고 아무것도 하지 않아야 합니다. 적용 가능할 때는 트랜잭션을 전달하고 true를 반환해야 합니다. 이것은 예를 들어 키맵 플러그인에서 해당 키에 연결된 명령이 적용되었을 때 키 이벤트의 추가 처리를 중지하는 데 사용됩니다.

실제로 실행하지 않고 명령이 특정 상태에 적용 가능한지 조회할 수 있으려면, `dispatch` 인수는 선택사항입니다. 명령은 적용 가능하지만 `dispatch` 인수가 제공되지 않았을 때 단순히 아무것도 하지 않고 true를 반환해야 합니다. 따라서 예제 명령은 실제로 다음과 같아야 합니다:

```javascript
function deleteSelection(state, dispatch) {
  if (state.selection.empty) return false;
  if (dispatch) dispatch(state.tr.deleteSelection());
  return true;
}
```

선택이 현재 삭제될 수 있는지 알아내려면, `deleteSelection(view.state, null)`을 호출하고, 실제로 명령을 실행하려면 `deleteSelection(view.state, view.dispatch)`와 같이 하면 됩니다. 메뉴 바는 이를 사용하여 어떤 메뉴 항목을 회색으로 표시할지 결정할 수 있습니다.

이 형태에서 명령은 실제 에디터 뷰에 접근하지 않습니다. 대부분의 명령은 이것이 필요하지 않으며, 이러한 방식으로 뷰가 사용 가능하지 않은 설정에서 적용되고 테스트될 수 있습니다. 하지만 일부 명령은 DOM과 상호작용해야 합니다. 특정 위치가 텍스트블록의 끝에 있는지 조회해야 하거나 뷰를 기준으로 위치한 대화 상자를 열고 싶을 수 있습니다. 이를 위해, 명령을 호출하는 대부분의 플러그인은 전체 뷰인 세 번째 인수를 제공합니다.

```javascript
function blinkView(_state, dispatch, view) {
  if (dispatch) {
    view.dom.style.background = "yellow";
    setTimeout(() => (view.dom.style.background = ""), 1000);
  }
  return true;
}
```

이(다소 쓸모없는) 예제는 명령이 트랜잭션을 전달할 필요가 없음을 보여줍니다. 이들은 부작용을 위해 호출되며, 이는 일반적으로 트랜잭션을 전달하는 것이지만 대화 상자를 띄우는 것과 같은 다른 것일 수도 있습니다.

`prosemirror-commands` 모듈은 `deleteSelection` 명령의 변형과 같은 간단한 것부터 텍스트블록의 시작 부분에서 백스페이스를 눌렀을 때 발생해야 하는 블록 결합 동작을 구현하는 `joinBackward`와 같은 상당히 복잡한 것까지 여러 편집 명령을 제공합니다. 또한 일반적으로 사용되는 키에 여러 스키마 독립적 명령을 연결하는 기본 키맵도 함께 제공됩니다.

가능한 경우, 일반적으로 단일 키에 연결되더라도 다른 동작은 다른 명령에 배치됩니다. 유틸리티 함수 `chainCommands`를 사용하여 여러 명령을 결합할 수 있습니다. 하나가 true를 반환할 때까지 차례로 시도됩니다.

예를 들어, 기본 키맵은 백스페이스를 명령 체인 `deleteSelection`(선택이 비어 있지 않을 때 시작), `joinBackward`(커서가 텍스트블록의 시작 부분에 있을 때), `selectNodeBackward`(스키마가 일반 결합 동작을 금지하는 경우 선택 앞의 노드를 선택)에 연결합니다. 이들 중 어느 것도 적용되지 않으면, 브라우저가 자체 백스페이스 동작을 실행하도록 허용되며, 이는 텍스트블록 내부의 것들을 백스페이스로 지우는 데 적절합니다(네이티브 맞춤법 검사 등이 혼동되지 않도록).

commands 모듈은 또한 마크 타입과 선택적으로 속성 세트를 받아 현재 선택에서 해당 마크를 토글하는 명령 함수를 반환하는 `toggleMark`와 같은 여러 명령 생성자를 내보냅니다.

일부 다른 모듈도 명령 함수를 내보냅니다. 예를 들어 history 모듈의 `undo`와 `redo`가 있습니다. 에디터를 맞춤 설정하거나 사용자가 맞춤 문서 노드와 상호작용할 수 있도록 하려면, 자신만의 맞춤 명령을 작성하고 싶을 것입니다.

## 공동 편집 이해하기

실시간 공동 편집은 여러 사람이 동시에 같은 문서를 편집할 수 있게 합니다. 그들이 만드는 변경 사항은 즉시 로컬 문서에 적용되고, 그런 다음 다른 사용자에게 전송되며, 다른 사용자는 이러한 변경 사항을 (수동 충돌 해결 없이) 자동으로 병합하여, 편집이 중단 없이 진행될 수 있고 문서가 계속 수렴하도록 합니다.

이 가이드는 ProseMirror의 공동 편집 기능을 연결하는 방법을 설명합니다.

### 알고리즘

ProseMirror의 공동 편집 시스템은 변경 사항이 적용되는 순서를 결정하는 중앙 권한을 사용합니다. 두 에디터가 동시에 변경을 하면, 둘 다 자신의 변경 사항을 가지고 이 권한에 갈 것입니다. 권한은 그들 중 하나의 변경 사항을 수락하고, 이러한 변경 사항을 모든 에디터에 전파할 것입니다. 다른 쪽의 변경 사항은 수락되지 않으며, 그 에디터가 서버로부터 새 변경 사항을 받으면, 로컬 변경 사항을 다른 에디터의 것 위에 리베이스하고 다시 제출을 시도해야 합니다.

### 권한 구현하기

중앙 권한의 역할은 실제로 상당히 간단합니다. 다음을 해야 합니다:

- 현재 문서 버전 추적
- 에디터로부터 변경 사항을 수락하고, 적용할 수 있을 때 변경 사항 목록에 추가
- 에디터가 특정 버전 이후의 변경 사항을 받을 수 있는 방법 제공

에디터와 동일한 JavaScript 환경에서 실행되는 간단한 중앙 권한을 구현해봅시다.

```javascript
class Authority {
  constructor(doc) {
    this.doc = doc;
    this.steps = [];
    this.stepClientIDs = [];
    this.onNewSteps = [];
  }

  receiveSteps(version, steps, clientID) {
    if (version != this.steps.length) return;
    steps.forEach((step) => {
      this.doc = step.apply(this.doc).doc;
      this.steps.push(step);
      this.stepClientIDs.push(clientID);
    });
    this.onNewSteps.forEach(function (f) {
      f();
    });
  }

  stepsSince(version) {
    return {
      steps: this.steps.slice(version),
      clientIDs: this.stepClientIDs.slice(version),
    };
  }
}
```

에디터가 권한에 변경 사항을 제출하려고 할 때, `receiveSteps`를 호출하여 수신한 마지막 버전 번호와 추가한 새 변경 사항, 그리고 클라이언트 ID(나중에 어떤 변경 사항이 자신에게서 왔는지 인식하는 방법)를 전달할 수 있습니다.

단계가 수락되면, 클라이언트는 권한이 새 단계를 사용할 수 있다고 알려주기 때문에 이를 알게 됩니다. 그러면 권한은 클라이언트에게 그들 자신의 단계를 제공합니다. 실제 구현에서는 `receiveSteps`가 상태를 반환하고 전송된 단계를 즉시 확인하는 것을 성능 최적화로 사용할 수도 있습니다. 하지만 여기서 사용되는 메커니즘은 불안정한 연결에서도 동기화를 보장하는 데 필요하므로, 항상 기본 방식으로 사용해야 합니다.

이 권한 구현은 계속 늘어나는 단계 배열을 유지하며, 배열의 길이가 현재 버전 번호를 나타냅니다.

### collab 모듈 사용하기

`collab` 모듈은 `collab` 함수를 제공하며, 이 함수는 플러그인을 반환합니다. 이 플러그인은 로컬에서 발생한 변경 사항 추적하기, 다른 곳에서 발생한 변경 사항 받기, 그리고 중앙 권한에 무언가를 보내야 할 때를 알려주는 일을 처리합니다.

```javascript
import { EditorState } from "prosemirror-state";
import { EditorView } from "prosemirror-view";
import { schema } from "prosemirror-schema-basic";
import collab from "prosemirror-collab";

function collabEditor(authority, place) {
  let view = new EditorView(place, {
    state: EditorState.create({
      doc: authority.doc,
      plugins: [collab.collab({ version: authority.steps.length })],
    }),
    dispatchTransaction(transaction) {
      let newState = view.state.apply(transaction);
      view.updateState(newState);
      let sendable = collab.sendableSteps(newState);
      if (sendable)
        authority.receiveSteps(
          sendable.version,
          sendable.steps,
          sendable.clientID
        );
    },
  });

  authority.onNewSteps.push(function () {
    let newData = authority.stepsSince(collab.getVersion(view.state));
    view.dispatch(
      collab.receiveTransaction(view.state, newData.steps, newData.clientIDs)
    );
  });

  return view;
}
```

`collabEditor` 함수는 `collab` 플러그인이 로드된 에디터 뷰를 만듭니다. 상태가 업데이트될 때마다, 권한에 보낼 것이 있는지 확인합니다. 있으면 보냅니다.

또한 권한이 새 단계를 사용할 수 있을 때 호출해야 하는 함수를 등록하고, 이 함수는 로컬 에디터 상태를 업데이트하여 해당 단계를 반영하는 트랜잭션을 만듭니다.

단계 세트가 권한에 의해 거부되면, 아마도 곧 권한으로부터 새 단계를 받을 때까지 확인되지 않은 상태로 유지될 것입니다. 그 후에, `onNewSteps` 콜백이 `dispatch`를 호출하기 때문에, 이는 우리의 `dispatchTransaction` 함수를 호출할 것이며, 코드는 다시 변경 사항을 제출하려고 시도할 것입니다.

이것이 전부입니다. 물론, 비동기 데이터 채널(collab 데모의 롱 폴링이나 웹 소켓과 같은)을 사용하면, 다소 더 복잡한 통신 및 동기화 코드가 필요할 것입니다. 그리고 아마도 권한이 어느 시점에서 단계를 버리기 시작하여 메모리 소비가 무한정 증가하지 않도록 하고 싶을 것입니다. 하지만 일반적인 접근 방식은 이 작은 예제에 의해 완전히 설명됩니다.
